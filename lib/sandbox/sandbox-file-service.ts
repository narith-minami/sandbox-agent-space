import type { Sandbox } from '@vercel/sandbox';
import { addLog } from '@/lib/db/queries';

/**
 * SandboxFileService - Handles file operations in sandbox
 *
 * Responsibilities:
 * - Write files to sandbox
 * - Read files from sandbox
 * - Write plan files with directory creation
 * - Download and prepare Gist scripts
 */
export class SandboxFileService {
  /**
   * Write plan text to file in sandbox
   */
  async writePlanFile(
    sessionId: string,
    sandbox: Sandbox,
    planText: string,
    planFilePath: string
  ): Promise<void> {
    try {
      // Ensure parent directory exists
      const dirPath = planFilePath.substring(0, planFilePath.lastIndexOf('/'));
      if (dirPath) {
        await sandbox.runCommand('mkdir', ['-p', dirPath]);
      }

      // Write plan text as file
      await sandbox.writeFiles([
        {
          path: planFilePath,
          content: Buffer.from(planText, 'utf-8'),
        },
      ]);

      await addLog({
        sessionId,
        level: 'info',
        message: `Plan file created at ${planFilePath}`,
      });
    } catch (error) {
      await addLog({
        sessionId,
        level: 'error',
        message: `Failed to write plan file: ${error instanceof Error ? error.message : 'Unknown error'}`,
      });
    }
  }

  /**
   * Download script from Gist and prepare for execution
   */
  async downloadAndPrepareGist(
    sessionId: string,
    sandbox: Sandbox,
    gistUrl: string
  ): Promise<void> {
    await addLog({
      sessionId,
      level: 'info',
      message: 'Downloading script from Gist...',
    });

    const downloadResult = await sandbox.runCommand('curl', ['-fsSL', gistUrl, '-o', 'run.sh']);
    if (downloadResult.exitCode !== 0) {
      const stderr = await downloadResult.stderr();
      throw new Error(`Failed to download script: ${stderr}`);
    }

    await sandbox.runCommand('chmod', ['+x', 'run.sh']);

    await addLog({
      sessionId,
      level: 'info',
      message: 'Script downloaded, starting execution...',
    });
  }

  /**
   * Create .env.local in sandbox for Gist scripts (e.g. integrated-review-workflow.sh).
   * Writes to /vercel/sandbox/.env.local (sandbox API allows writes under cwd; /vercel/ may return 400).
   * Script must look for SCRIPT_DIR/.env.local so it finds this file when run as run.sh.
   */
  static readonly ENV_LOCAL_PATH = '/vercel/sandbox/.env.local';

  async prepareEnvFile(
    sessionId: string,
    sandbox: Sandbox,
    env: Record<string, string | undefined>
  ): Promise<void> {
    const lines: string[] = [
      '# Generated by host for sandbox (integrated-review-workflow.sh etc.)',
      '',
    ];
    const keys = ['ANTHROPIC_API_KEY', 'OPENAI_API_KEY', 'GEMINI_API_KEY', 'GITHUB_TOKEN'] as const;
    for (const key of keys) {
      const value = env[key];
      if (value) {
        lines.push(`${key}=${value}`);
      }
    }
    if (lines.length <= 2) {
      await addLog({
        sessionId,
        level: 'debug',
        message: 'No AI API keys in env; skipping .env.local creation',
      });
      return;
    }
    const content = lines.join('\n');
    try {
      await sandbox.writeFiles([
        {
          path: SandboxFileService.ENV_LOCAL_PATH,
          content: Buffer.from(content, 'utf-8'),
        },
      ]);
      await addLog({
        sessionId,
        level: 'info',
        message: `Created ${SandboxFileService.ENV_LOCAL_PATH} for Gist workflow`,
      });
    } catch (error) {
      await addLog({
        sessionId,
        level: 'error',
        message: `Failed to create .env.local: ${error instanceof Error ? error.message : 'Unknown error'}`,
      });
      throw error;
    }
  }

  /**
   * Write files to sandbox
   */
  async writeFiles(
    sessionId: string,
    sandbox: Sandbox,
    files: { path: string; content: Buffer }[]
  ): Promise<void> {
    await sandbox.writeFiles(files);
    await addLog({
      sessionId,
      level: 'info',
      message: `Wrote ${files.length} file(s) to sandbox.`,
    });
  }

  /**
   * Read file from sandbox
   */
  async readFile(sandbox: Sandbox, path: string): Promise<Buffer | null> {
    return sandbox.readFileToBuffer({ path });
  }
}
