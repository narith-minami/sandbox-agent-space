#!/usr/bin/env node
/**
 * analyze-review.js
 * AI Code Review„ÅÆÁµêÊûú„ÇíËß£Êûê„Åó„Å¶Âà§ÂÆö„ÇíË°å„ÅÜ
 *
 * Usage:
 *   node analyze-review.js [review-directory]
 *
 * Output: JSONÂΩ¢Âºè„ÅÆÂàÜÊûêÁµêÊûú
 */

const fs = require('fs');
const path = require('path');

const reviewDir = process.argv[2] || './ai-review-results';

if (!fs.existsSync(reviewDir)) {
  console.error(`Review directory not found: ${reviewDir}`);
  process.exit(1);
}

const reviewFiles = fs
  .readdirSync(reviewDir)
  .filter((f) => f.endsWith('.json') || f.endsWith('.md'))
  .map((f) => path.join(reviewDir, f));

if (reviewFiles.length === 0) {
  console.log(
    JSON.stringify({
      totalIssues: 0,
      bySeverity: { critical: 0, high: 0, medium: 0, low: 0 },
      needsFix: false,
      criticalIssues: [],
      message: 'No review files found',
    })
  );
  process.exit(0);
}

const allIssues = [];
const issuesByFile = new Map();
const issuesBySeverity = { critical: [], high: [], medium: [], low: [] };

// „É¨„Éì„É•„Éº„Éï„Ç°„Ç§„É´Ëß£Êûê
reviewFiles.forEach((file) => {
  try {
    const content = fs.readFileSync(file, 'utf-8');

    // JSONÂΩ¢Âºè„ÅÆÂ†¥Âêà
    if (file.endsWith('.json')) {
      const data = JSON.parse(content);
      const issues = data.issues || data.findings || [];

      issues.forEach((issue) => {
        processIssue(issue);
      });
    }

    // MarkdownÂΩ¢Âºè„ÅÆÂ†¥ÂêàÔºà„Éë„Çø„Éº„É≥„Éû„ÉÉ„ÉÅ„É≥„Ç∞Ôºâ
    if (file.endsWith('.md')) {
      // Severity „Éë„Çø„Éº„É≥
      const severityPattern = /\*\*Severity:\*\*\s*(Critical|High|Medium|Low)/gi;
      let match;

      while ((match = severityPattern.exec(content)) !== null) {
        const severity = match[1].toLowerCase();
        const contextStart = Math.max(0, match.index - 200);
        const contextEnd = Math.min(content.length, match.index + 500);
        const context = content.substring(contextStart, contextEnd);

        // „Éï„Ç°„Ç§„É´Âêç„Å®„Ç´„ÉÜ„Ç¥„É™„ÇíÊäΩÂá∫
        const fileMatch = context.match(/File:\s*`([^`]+)`/);
        const categoryMatch = context.match(/Category:\s*([^\n]+)/);
        const lineMatch = context.match(/Line:\s*(\d+)/);
        const descMatch = context.match(/Issue:\s*([^\n]+)/);

        const issue = {
          severity,
          file: fileMatch ? fileMatch[1] : 'unknown',
          category: categoryMatch ? categoryMatch[1].trim() : 'general',
          line: lineMatch ? parseInt(lineMatch[1]) : null,
          description: descMatch ? descMatch[1].trim() : context.substring(0, 200),
        };

        processIssue(issue);
      }
    }
  } catch (e) {
    console.error(`Failed to parse ${file}: ${e.message}`);
  }
});

function processIssue(issue) {
  allIssues.push(issue);

  // „Éï„Ç°„Ç§„É´Âà•ÈõÜË®à
  const fileName = issue.file || 'unknown';
  if (!issuesByFile.has(fileName)) {
    issuesByFile.set(fileName, []);
  }
  issuesByFile.get(fileName).push(issue);

  // Ê∑±ÂàªÂ∫¶Âà•ÈõÜË®à
  const severity = (issue.severity || 'low').toLowerCase();
  if (issuesBySeverity[severity]) {
    issuesBySeverity[severity].push(issue);
  } else {
    // unknown severity -> low „Å®„Åó„Å¶Êâ±„ÅÜ
    issuesBySeverity.low.push(issue);
  }
}

// ÂàÜÊûêÁµêÊûú
const analysis = {
  totalIssues: allIssues.length,
  bySeverity: {
    critical: issuesBySeverity.critical.length,
    high: issuesBySeverity.high.length,
    medium: issuesBySeverity.medium.length,
    low: issuesBySeverity.low.length,
  },
  criticalIssues: issuesBySeverity.critical.concat(issuesBySeverity.high),
  needsFix: issuesBySeverity.critical.length > 0 || issuesBySeverity.high.length > 0,
  issuesByFile: Object.fromEntries(
    Array.from(issuesByFile.entries()).map(([file, issues]) => [
      file,
      {
        count: issues.length,
        critical: issues.filter((i) => i.severity === 'critical').length,
        high: issues.filter((i) => i.severity === 'high').length,
        medium: issues.filter((i) => i.severity === 'medium').length,
        low: issues.filter((i) => i.severity === 'low').length,
      },
    ])
  ),
  reviewFiles: reviewFiles.map((f) => path.basename(f)),
};

// JSONÂá∫Âäõ
console.log(JSON.stringify(analysis, null, 2));

// ‰øÆÊ≠£ÊåáÁ§∫„Éï„Ç°„Ç§„É´ÁîüÊàê
if (analysis.needsFix) {
  const fixInstructions = analysis.criticalIssues
    .map((issue, idx) => {
      return `${idx + 1}. [${(issue.severity || 'unknown').toUpperCase()}] ${issue.file}:${issue.line || 'N/A'}
   Category: ${issue.category || 'general'}
   Issue: ${issue.description || issue.message || 'No description'}
   ${issue.suggestion ? `Suggestion: ${issue.suggestion}` : ''}
`;
    })
    .join('\n');

  fs.writeFileSync(
    path.join(reviewDir, 'fix-instructions.txt'),
    `Critical and High Severity Issues Requiring Fixes:

Found ${analysis.criticalIssues.length} critical/high severity issues that need attention.

${fixInstructions}

---
Generated by analyze-review.js at ${new Date().toISOString()}
`
  );

  console.error(`\n‚ö†Ô∏è  ${analysis.criticalIssues.length} Critical/High issues found.`);
  console.error(`üìù Fix instructions written to: ${path.join(reviewDir, 'fix-instructions.txt')}`);
}

// Exit code: 0 if no critical/high issues, 1 otherwise
process.exit(analysis.needsFix ? 1 : 0);
